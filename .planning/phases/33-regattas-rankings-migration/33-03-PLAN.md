---
phase: 33-regattas-rankings-migration
plan: 03
type: execute
wave: 2
depends_on: [33-01, 33-02]
files_modified:
  - server/socket/raceDay.js
  - server/index.js
  - src/v2/features/regatta/hooks/useRaceDaySocket.ts
  - src/v2/features/regatta/hooks/useConnectionHealth.ts
  - src/v2/features/regatta/components/ConnectionIndicator.tsx
  - src/services/collaborationService.ts
  - src/v2/lib/queryKeys.ts
autonomous: true

must_haves:
  truths:
    - "User sees connection health indicator (green/yellow/red dot) on race day pages"
    - "User sees live race result updates appear without page refresh when another user submits results"
    - "User sees connection status change from green to yellow/red when network degrades"
    - "WebSocket server handles race day events (join room, broadcast results, ranking updates)"
  artifacts:
    - path: "server/socket/raceDay.js"
      provides: "Race day WebSocket event handlers for result broadcasting and ranking updates"
      min_lines: 80
    - path: "src/v2/features/regatta/hooks/useRaceDaySocket.ts"
      provides: "React hook for race day WebSocket events with TanStack Query cache integration"
      min_lines: 60
    - path: "src/v2/features/regatta/hooks/useConnectionHealth.ts"
      provides: "Hook monitoring Socket.IO connection status and retry count"
      min_lines: 50
    - path: "src/v2/features/regatta/components/ConnectionIndicator.tsx"
      provides: "Visual connection status badge (green=live, yellow=reconnecting, red=offline)"
      min_lines: 40
  key_links:
    - from: "server/index.js"
      to: "server/socket/raceDay.js"
      via: "import and initialize race day socket alongside collaboration"
      pattern: "initializeRaceDaySocket"
    - from: "src/v2/features/regatta/hooks/useRaceDaySocket.ts"
      to: "src/services/collaborationService.ts"
      via: "getSocket() to access shared Socket.IO connection"
      pattern: "collaborationService"
    - from: "src/v2/features/regatta/hooks/useRaceDaySocket.ts"
      to: "src/v2/lib/queryKeys.ts"
      via: "invalidateQueries on race result broadcast"
      pattern: "queryKeys.races"
---

<objective>
Build WebSocket infrastructure for real-time race day updates and connection health monitoring.

Purpose: Enable live race result broadcasting during regattas (REG-02, RT-02, RT-03). This replaces polling with WebSocket for sub-second update latency during race day. The connection health indicator (RT-02) provides constant awareness of connection status -- critical at regatta venues with poor cell service.

Output: Server-side race day WebSocket handlers, client-side hooks for consuming live events, and a visual connection status indicator component.
</objective>

<execution_context>
@/home/swd/.claude/get-shit-done/workflows/execute-plan.md
@/home/swd/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-regattas-rankings-migration/33-RESEARCH.md
@server/socket/collaboration.js
@src/services/collaborationService.ts
@src/v2/lib/queryKeys.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Server-side race day WebSocket events and Socket.IO wiring</name>
  <files>
    server/socket/raceDay.js
    server/index.js
    server/socket/collaboration.js
  </files>
  <action>
    Create the server-side WebSocket event handlers for race day and ensure Socket.IO is properly wired into the Express server.

    **Step 1: Verify Socket.IO wiring in server/index.js**

    The existing `server/index.js` uses `app.listen()` which does NOT create an HTTP server compatible with Socket.IO. Check if Socket.IO is already wired. If NOT:

    1. Import `createServer` from `http`
    2. Create `httpServer = createServer(app)`
    3. Import `initializeWebSocket` from `./socket/collaboration.js`
    4. Call `initializeWebSocket(httpServer)` — this returns the `io` instance
    5. Import `initializeRaceDaySocket` from `./socket/raceDay.js`
    6. Call `initializeRaceDaySocket(io)` — pass the existing io instance
    7. Change `app.listen(PORT, ...)` to `httpServer.listen(PORT, ...)`

    If Socket.IO IS already wired, simply add the race day import and initialization.

    **Step 2: Create `server/socket/raceDay.js`**

    Race day WebSocket event handlers extending the existing Socket.IO server:

    ```javascript
    import logger from '../utils/logger.js';

    // Active regatta rooms: regattaId -> { viewers, lastActivity }
    const regattaRooms = new Map();

    export function initializeRaceDaySocket(io) {
      io.on('connection', (socket) => {

        // Join race day room
        socket.on('raceday:join', ({ regattaId }) => {
          socket.join(`regatta-${regattaId}`);

          if (!regattaRooms.has(regattaId)) {
            regattaRooms.set(regattaId, { viewers: 0, lastActivity: Date.now() });
          }
          const room = regattaRooms.get(regattaId);
          room.viewers++;

          // Notify room of new viewer count
          io.to(`regatta-${regattaId}`).emit('raceday:viewers', {
            count: room.viewers,
          });

          logger.info('User joined race day', { regattaId, userId: socket.user?.id });
        });

        // Leave race day room
        socket.on('raceday:leave', ({ regattaId }) => {
          socket.leave(`regatta-${regattaId}`);
          const room = regattaRooms.get(regattaId);
          if (room) {
            room.viewers = Math.max(0, room.viewers - 1);
            io.to(`regatta-${regattaId}`).emit('raceday:viewers', {
              count: room.viewers,
            });
          }
        });

        // Broadcast new race result to all watchers
        socket.on('raceday:result:submit', ({ regattaId, raceId, result }) => {
          // Broadcast to everyone in the regatta room (including sender for confirmation)
          io.to(`regatta-${regattaId}`).emit('raceday:result:new', {
            raceId,
            result,
            submittedBy: socket.user?.name || 'Unknown',
            timestamp: Date.now(),
          });

          const room = regattaRooms.get(regattaId);
          if (room) room.lastActivity = Date.now();

          logger.info('Race result broadcast', { regattaId, raceId });
        });

        // Broadcast ranking recalculation
        socket.on('raceday:rankings:updated', ({ regattaId, rankings }) => {
          io.to(`regatta-${regattaId}`).emit('raceday:rankings:update', {
            rankings,
            timestamp: Date.now(),
          });
          logger.info('Rankings broadcast', { regattaId, count: rankings?.length });
        });

        // Handle disconnect - decrement viewer count
        socket.on('disconnect', () => {
          // Socket.IO auto-removes from rooms, but we track viewer count
          for (const [regattaId, room] of regattaRooms.entries()) {
            // Can't easily know which regatta rooms this socket was in
            // Room cleanup handled by periodic sweep below
          }
        });
      });

      // Periodic cleanup of stale regatta rooms (no viewers, no activity for 30 min)
      setInterval(() => {
        const now = Date.now();
        const staleThreshold = 30 * 60 * 1000;
        for (const [regattaId, room] of regattaRooms.entries()) {
          if (room.viewers === 0 && now - room.lastActivity > staleThreshold) {
            regattaRooms.delete(regattaId);
            logger.debug('Stale regatta room cleaned', { regattaId });
          }
        }
      }, 5 * 60 * 1000);

      logger.info('Race day WebSocket handlers initialized');
    }
    ```

    Use namespaced event names (`raceday:*`) to avoid collision with existing collaboration events (`session:*`, `lineup:*`, `cursor:*`). Per RESEARCH.md Pitfall 1.

    **Important:** The `initializeRaceDaySocket` function receives the SAME `io` instance from collaboration.js. It adds additional event listeners on `io.on('connection')`. Socket.IO supports multiple `connection` handlers on the same server.
  </action>
  <verify>
    Run `node -e "import('./server/socket/raceDay.js').then(m => console.log(typeof m.initializeRaceDaySocket))"` to verify the module exports correctly.
    Start the server with `cd /home/swd/RowLab && timeout 5 node server/index.js 2>&1 || true` and verify no import errors.
  </verify>
  <done>
    Server-side race day WebSocket handlers exist and are wired into the Express server. The server starts without errors. Race day events use `raceday:*` namespace to avoid collision with existing collaboration events.
  </done>
</task>

<task type="auto">
  <name>Task 2: Client-side WebSocket hooks and ConnectionIndicator component</name>
  <files>
    src/v2/features/regatta/hooks/useRaceDaySocket.ts
    src/v2/features/regatta/hooks/useConnectionHealth.ts
    src/v2/features/regatta/components/ConnectionIndicator.tsx
    src/services/collaborationService.ts
    src/v2/lib/queryKeys.ts
  </files>
  <action>
    Create client-side hooks for consuming race day WebSocket events and a connection health indicator component.

    **Step 1: Check `src/services/collaborationService.ts`**

    Verify it has a `getSocket()` method or equivalent for accessing the shared Socket.IO connection. If not, add a method that returns the current socket instance. The race day hooks need to tap into the same Socket.IO connection.

    **Step 2: Create `src/v2/features/regatta/hooks/useRaceDaySocket.ts`**

    Hook that manages race day WebSocket subscription:

    - Accepts `{ regattaId: string; enabled?: boolean }`
    - On mount (if enabled): emits `raceday:join` with regattaId
    - Listens for `raceday:result:new` -> invalidates race query via TanStack Query
    - Listens for `raceday:rankings:update` -> optimistically updates rankings cache
    - Listens for `raceday:viewers` -> tracks viewer count
    - On unmount: emits `raceday:leave`
    - Returns `{ liveResults, viewerCount, isConnected }`
    - Use debounced invalidation (2 second debounce) per RESEARCH.md Pitfall 3 to prevent broadcast storm

    Add `raceday` query key factory to `queryKeys.ts` if needed:
    ```typescript
    raceday: {
      all: ['raceday'] as const,
      viewers: (regattaId: string) => [...queryKeys.raceday.all, 'viewers', regattaId] as const,
    }
    ```

    **Step 3: Create `src/v2/features/regatta/hooks/useConnectionHealth.ts`**

    Hook monitoring Socket.IO connection status:

    - Listens to socket `connect`, `disconnect`, `connect_error` events
    - Tracks `status: 'connected' | 'degraded' | 'offline'`
    - Tracks `retryCount` (increments on `connect_error`)
    - Tracks `lastConnected: Date | null`
    - Resets retryCount on successful connect
    - Returns `{ status, retryCount, lastConnected, isHealthy }`

    **Step 4: Create `src/v2/features/regatta/components/ConnectionIndicator.tsx`**

    Visual connection status badge per RESEARCH.md Pattern 2:

    - Props: `status: ConnectionStatus, retryCount?: number`
    - Green dot + "Live" text when connected (with pulsing animation)
    - Yellow dot + "Reconnecting..." when degraded (shows retry count)
    - Red dot + "Offline" when offline
    - Uses V3 design tokens: `data-excellent` (green), `data-warning` (yellow), `data-poor` (red)
    - Rounded pill shape with `bg-{color}/10` background
    - Icons from lucide-react: Wifi (connected), AlertTriangle (degraded), WifiOff (offline)
    - Pulse animation on green dot using Framer Motion

    Create the features/regatta directory structure if it doesn't exist:
    ```
    src/v2/features/regatta/
    ├── components/
    │   └── ConnectionIndicator.tsx
    └── hooks/
        ├── useRaceDaySocket.ts
        └── useConnectionHealth.ts
    ```
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify TypeScript compiles clean.
    Run `grep -n 'useRaceDaySocket\|useConnectionHealth\|ConnectionIndicator' src/v2/features/regatta/hooks/*.ts src/v2/features/regatta/components/*.tsx` to verify all files exist with correct exports.
  </verify>
  <done>
    Client-side WebSocket hooks (`useRaceDaySocket`, `useConnectionHealth`) and `ConnectionIndicator` component exist. Hooks integrate with collaborationService for Socket.IO access and TanStack Query for cache invalidation on live events. ConnectionIndicator uses V3 design tokens and Framer Motion for pulse animation.
  </done>
</task>

</tasks>

<verification>
- Server starts without import errors
- `npx tsc --noEmit` passes
- Race day Socket.IO event handlers registered on server
- Client hooks created with proper TypeScript types
- ConnectionIndicator renders with V3 design tokens
</verification>

<success_criteria>
WebSocket infrastructure for race day is complete. Server handles raceday:join, raceday:result:submit, raceday:rankings:updated events. Client hooks consume events and integrate with TanStack Query. ConnectionIndicator shows green/yellow/red status with animations.
</success_criteria>

<output>
After completion, create `.planning/phases/33-regattas-rankings-migration/33-03-SUMMARY.md`
</output>
